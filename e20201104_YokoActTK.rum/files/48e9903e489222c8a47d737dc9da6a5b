using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Charlotte.GameCommons;
using Charlotte.Commons;

namespace Charlotte.Games.Attacks
{
	public static class AttackCommon
	{
		public static void ProcPlayer_移動()
		{
			// 攻撃中は左右の方向転換を抑止する。

			double speed;

			if (1 <= DDInput.R.GetInput())
				speed = Consts.PLAYER_SLOW_SPEED;
			else
				speed = Consts.PLAYER_SPEED;

			if (1 <= DDInput.DIR_4.GetInput())
			{
				Game.I.Player.X -= speed;
				//Game.I.Player.FacingLeft = true; // 抑止
			}
			if (1 <= DDInput.DIR_6.GetInput())
			{
				Game.I.Player.X += speed;
				//Game.I.Player.FacingLeft = false; // 抑止
			}
		}

		public static void ProcPlayer_Fall()
		{
			if (1 <= Game.I.Player.JumpFrame) // ? ジャンプ中(だった)
			{
				if (DDInput.A.GetInput() <= 0) // ? ジャンプを中断・終了した。
				{
					Game.I.Player.JumpFrame = 0;

					if (Game.I.Player.YSpeed < 0.0)
						Game.I.Player.YSpeed /= 2.0;
				}
			}

			// 重力による加速
			Game.I.Player.YSpeed += Consts.PLAYER_GRAVITY;

			// 自由落下の最高速度を超えないように矯正
			DDUtils.Minim(ref Game.I.Player.YSpeed, Consts.PLAYER_FALL_SPEED_MAX);

			// 自由落下
			Game.I.Player.Y += Game.I.Player.YSpeed;
		}

		// ---- 接地系判定 ----

		public static bool IsPlayer_側面()
		{
			return GetPlayer_側面() != 0;
		}

		public static int GetPlayer_側面()
		{
			bool touchSide_L =
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X - Consts.PLAYER_側面判定Pt_X, Game.I.Player.Y - Consts.PLAYER_側面判定Pt_Y)).Tile.IsWall() ||
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X - Consts.PLAYER_側面判定Pt_X, Game.I.Player.Y)).Tile.IsWall() ||
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X - Consts.PLAYER_側面判定Pt_X, Game.I.Player.Y + Consts.PLAYER_側面判定Pt_Y)).Tile.IsWall();

			bool touchSide_R =
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X + Consts.PLAYER_側面判定Pt_X, Game.I.Player.Y - Consts.PLAYER_側面判定Pt_Y)).Tile.IsWall() ||
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X + Consts.PLAYER_側面判定Pt_X, Game.I.Player.Y)).Tile.IsWall() ||
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X + Consts.PLAYER_側面判定Pt_X, Game.I.Player.Y + Consts.PLAYER_側面判定Pt_Y)).Tile.IsWall();

			return (touchSide_L ? 1 : 0) | (touchSide_R ? 2 : 0);
		}

		public static bool IsPlayer_脳天()
		{
			bool touchCeiling =
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X - Consts.PLAYER_脳天判定Pt_X, Game.I.Player.Y - Consts.PLAYER_脳天判定Pt_Y)).Tile.IsWall() ||
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X + Consts.PLAYER_脳天判定Pt_X, Game.I.Player.Y - Consts.PLAYER_脳天判定Pt_Y)).Tile.IsWall();

			return touchCeiling;
		}

		public static bool IsPlayer_接地()
		{
			bool touchGround =
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X - Consts.PLAYER_接地判定Pt_X, Game.I.Player.Y + Consts.PLAYER_接地判定Pt_Y)).Tile.IsWall() ||
				Game.I.Map.GetCell(Common.ToTablePoint(Game.I.Player.X + Consts.PLAYER_接地判定Pt_X, Game.I.Player.Y + Consts.PLAYER_接地判定Pt_Y)).Tile.IsWall();

			return touchGround;
		}

		// ---- 接地系処理 ----

		public static bool ProcPlayer_側面()
		{
			int flag = GetPlayer_側面();

			if (flag == 3) // 左右両方
			{
				// noop
			}
			else if (flag == 1) // 左側面
			{
				Game.I.Player.X = (double)SCommon.ToInt(Game.I.Player.X / Consts.TILE_W) * Consts.TILE_W + Consts.PLAYER_側面判定Pt_X;
			}
			else if (flag == 2) // 右側面
			{
				Game.I.Player.X = (double)SCommon.ToInt(Game.I.Player.X / Consts.TILE_W) * Consts.TILE_W - Consts.PLAYER_側面判定Pt_X;
			}
			else
			{
				throw null; // never
			}
			return flag != 0;
		}

		public static bool ProcPlayer_脳天()
		{
			bool ret = IsPlayer_脳天();

			if (ret)
			{
				if (Game.I.Player.YSpeed < 0.0)
				{
					Game.I.Player.Y = ((int)((Game.I.Player.Y - Consts.PLAYER_脳天判定Pt_Y) / Consts.TILE_H) + 1) * Consts.TILE_H + Consts.PLAYER_脳天判定Pt_Y;
					Game.I.Player.YSpeed = 0.0;
				}
			}
			return ret;
		}

		public static bool ProcPlayer_接地()
		{
			bool ret = IsPlayer_接地();

			if (ret)
			{
				DDUtils.Minim(ref Game.I.Player.YSpeed, 0.0);

				double plY = (int)((Game.I.Player.Y + Consts.PLAYER_接地判定Pt_Y) / Consts.TILE_H) * Consts.TILE_H - Consts.PLAYER_接地判定Pt_Y;

				DDUtils.Minim(ref Game.I.Player.Y, plY);
			}
			return ret;
		}

		// ----
	}
}
